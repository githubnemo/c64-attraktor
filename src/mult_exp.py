# this was generated by ChatGPT and I'm not sure if it is correct.
# It looks OK but errors might be subtle.
#
# the wiki states:
# Mantissa: (m4 >= 128 ? -1 : +1) * ((m4 | 0x80) >> 8 + m3 >> 16 + m2 >> 24 + m1 >> 32)
# as a C-language like expression, with "x >> y" as "float multiply x by 2â†‘(-y)" (right-bit-shift operation)

import decimal


def cbm_float_to_python_float(hex_bytes):
    # Ensure we have exactly 5 bytes
    if len(hex_bytes) != 5:
        raise ValueError("CBM float requires exactly 5 bytes")

    # Extract the exponent and bias it by subtracting 128
    exponent = hex_bytes[0] - 128

    # Extract the mantissa as a 4-byte integer
    mantissa = (hex_bytes[1] << 24) | (hex_bytes[2] << 16) | (hex_bytes[3] << 8) | hex_bytes[4]

    # The sign bit is in the MSB of the mantissa; 0 means positive, 1 means negative
    sign = -1 if (mantissa & 0x80000000) else 1

    mantissa |= 0x80000000 # TODO is this correct? shouldn't this be XOR to remove the sign bit

    #print(bin(mantissa), hex(mantissa))

    # Convert mantissa to a float by dividing by 2**31 (to match the fixed point range)
    float_value = sign * (mantissa / (2**32)) * (2 ** exponent)


    return float_value


def cbm_mult(hex1, hex2):
    return cbm_float_to_python_float(hex1) * cbm_float_to_python_float(hex2)


def _ieee_float_32(sign, exponent, mantissa):
    return (
        ((-1) ** sign) *
        (2**(exponent - 127)) *
        (1+sum([((mantissa >> (23-i)) & 1) * (1/2**i) for i in range(0, 24)]))
    )


def python_float_to_cbm_float(f):
    import struct
    f32 = struct.unpack('!I', struct.pack('!f', f))[0]
    sign = (f32 & 0x80000000) >> 31
    exponent = (f32 & 0x7f800000) >> 23
    mantissa = f32 & 0x007fffff

    extracted_float = _ieee_float_32(
        sign,
        exponent,
        mantissa,
        )

    #print(sign, exponent, mantissa)
    assert abs(extracted_float - f) < 1e-3, extracted_float

    mantissa_bytes = [
        (mantissa >> 16) & 0xff,
        (mantissa >>  8) & 0xff,
        (mantissa >>  0) & 0xff,
    ]

    #print(f'mantissa: {mantissa:024b}')
    #print([f'{n:08b}' for n in mantissa_bytes])

    mantissa_cbm = (
        sign << 31 |
        mantissa_bytes[0] << 24 |
        mantissa_bytes[1] << 16 |
        mantissa_bytes[2] << 0
    )

    #print(bin(mantissa_cbm))

    hex_bytes = [
        exponent + 2, # TODO check rebiasing
        mantissa_cbm >> 24 & 0xff,
        mantissa_cbm >> 16 & 0xff,
        mantissa_cbm >>  8 & 0xff,
        mantissa_cbm >>  0 & 0xff,
    ]

    return hex_bytes



z = cbm_float_to_python_float([0x80, 0x00, 0x00, 0x00, 0x00])
assert z == 0.5, z

z = cbm_float_to_python_float([0x81, 0x00, 0x00, 0x00, 0x00])
assert z == 1.0, z

z = cbm_float_to_python_float([0x81, 0x80, 0x00, 0x00, 0x00])
assert z == -1.0, z

cbm_hex = [0x98, 0x35, 0x44, 0x7a, 0x00]


if __name__ == "__main__":
    def convert(cbm_hex):
        result = cbm_float_to_python_float(cbm_hex)
        print("Converted CBM float to Python float:", result)

    import sys
    convert(([int(n, 16) for n in sys.argv[1:]] + [0x00] * 5)[:5])

    convert(python_float_to_cbm_float(0.5))
    convert(python_float_to_cbm_float(1.0))
    convert(python_float_to_cbm_float(2.0))
    convert(python_float_to_cbm_float(0.25))
    convert(python_float_to_cbm_float(0.33))
    convert(python_float_to_cbm_float(0.1234))
    convert(python_float_to_cbm_float(0.12345678))
    convert(python_float_to_cbm_float(-0.12345678))
